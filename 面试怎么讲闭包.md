#### 闭包这块要串起来讲的知识还是挺多的，这里只是对前几篇文章做一个大致的总结~

> 先从作用域开始，作用域就是一个区域——代码块中定义变量的区域。因为JS是词法作用域，所以函数作用域在函数定义的时候就已经确定。因为函数内部有一个[[Scope]]属性，在函数被创建的时候会将父级执行上下文中的变量对象添加到自己的[[Scope]]中，在函数被激活（调用）的时候，才会创建函数上下文，这时候就会开始函数上下文的创建和执行。在函数上下文创建阶段，就会创建其变量对象、作用域链以及确定this指向。创建变量对象的时候，会先建立函数的arguments对象，检查当前上下文中的参数，确定它之下的属性和属性值，接着会检查函数中的变量声明，这里是有一个优先级的，首先会将function关键字声明的函数标识符提到作用域的顶部并且在VO中建立一组键值对（键为函数名，值为函数的引用），接着才是var声明的普通变量和函数，这时候也会被添加到VO中（键为变量名，值为undefined），这也就是通常所述的变量提升。这里还需要注意在检查变量声明的时候，如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖；如果该变量名已经存在，为了防止同名函数被修改为undefined，会直接跳过该变量，原属性值不会被修改。接着就是创建自己的作用域链了，它首先会复制父上下文的VO，然后再把自己的VO添加到作用域链的最前端。这个时候就可以执行代码了，此阶段是顺序执行经过了变量提升后的代码，修改变量值的过程，因为只有VO被添加到作用域链的最前端变成AO的时候，才可以修改变量的值也就是给变量赋值和引用函数。执行函数的时候，会先从作用域链的最前端，也就是自己的VO中查找变量并进行修改，如果找不到，才会沿着作用域链向自己的父级去查找。执行完毕之后就会从上下文栈中弹出，这个时候吧其中的变量都会被销毁。而闭包就是因为在创建的时候将上层上下文的数据保存起来了，所以才可以在当前作用域之外执行也可以访问到自由变量